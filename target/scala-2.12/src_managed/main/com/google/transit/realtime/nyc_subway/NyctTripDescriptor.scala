// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO2

package com.google.transit.realtime.nyc_subway

/** NYCT Subway extensions for the trip descriptor
  *
  * @param trainId
  *   The nyct_train_id is meant for internal use only. It provides an
  *   easy way to associated GTFS-realtime trip identifiers with NYCT rail
  *   operations identifier 
  *   
  *   The ATS office system assigns unique train identification (Train ID) to
  *   each train operating within or ready to enter the mainline of the
  *   monitored territory. An example of this is 06 0123+ PEL/BBR and is decoded
  *   as follows: 
  *   
  *   The first character represents the trip type designator. 0 identifies a
  *   scheduled revenue trip. Other revenue trip values that are a result of a
  *   change to the base schedule include; [= reroute], [/ skip stop], [$ turn
  *   train] also known as shortly lined service.  
  *   
  *   The second character 6 represents the trip line i.e. number 6 train The
  *   third set of characters identify the decoded origin time. The last
  *   character may be blank "on the whole minute" or + "30 seconds" 
  *   
  *   Note: Origin times will not change when there is a trip type change.  This
  *   is followed by a three character "Origin Location" / "Destination
  *   Location"
  * @param isAssigned
  *   This trip has been assigned to a physical train. If true, this trip is
  *   already underway or most likely will depart shortly. 
  *  
  *   Train Assignment is a function of the Automatic Train Supervision (ATS)
  *   office system used by NYCT Rail Operations to monitor and track train
  *   movements. ATS provides the ability to "assign" the nyct_train_id
  *   attribute when a physical train is at its origin terminal. These assigned
  *   trips have the is_assigned field set in the TripDescriptor.
  *  
  *   When a train is at a terminal but has not been given a work program it is
  *   declared unassigned and is tagged as such. Unassigned trains can be moved
  *   to a storage location or assigned a nyct_train_id when a determination for
  *   service is made.
  * @param direction
  *   Uptown and Bronx-bound trains are moving NORTH.
  *   Times Square Shuttle to Grand Central is also northbound.
  *  
  *   Downtown and Brooklyn-bound trains are moving SOUTH.
  *   Times Square Shuttle to Times Square is also southbound.
  *   
  *   EAST and WEST are not used currently.
  */
@SerialVersionUID(0L)
final case class NyctTripDescriptor(
    trainId: _root_.scala.Option[_root_.scala.Predef.String] = _root_.scala.None,
    isAssigned: _root_.scala.Option[_root_.scala.Boolean] = _root_.scala.None,
    direction: _root_.scala.Option[com.google.transit.realtime.nyc_subway.NyctTripDescriptor.Direction] = _root_.scala.None
    ) extends scalapb.GeneratedMessage with scalapb.Message[NyctTripDescriptor] with scalapb.lenses.Updatable[NyctTripDescriptor] {
    @transient
    private[this] var __serializedSizeCachedValue: _root_.scala.Int = 0
    private[this] def __computeSerializedValue(): _root_.scala.Int = {
      var __size = 0
      if (trainId.isDefined) {
        val __value = trainId.get
        __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(1, __value)
      };
      if (isAssigned.isDefined) {
        val __value = isAssigned.get
        __size += _root_.com.google.protobuf.CodedOutputStream.computeBoolSize(2, __value)
      };
      if (direction.isDefined) {
        val __value = direction.get
        __size += _root_.com.google.protobuf.CodedOutputStream.computeEnumSize(3, __value.value)
      };
      __size
    }
    final override def serializedSize: _root_.scala.Int = {
      var read = __serializedSizeCachedValue
      if (read == 0) {
        read = __computeSerializedValue()
        __serializedSizeCachedValue = read
      }
      read
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      trainId.foreach { __v =>
        val __m = __v
        _output__.writeString(1, __m)
      };
      isAssigned.foreach { __v =>
        val __m = __v
        _output__.writeBool(2, __m)
      };
      direction.foreach { __v =>
        val __m = __v
        _output__.writeEnum(3, __m.value)
      };
    }
    def mergeFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): com.google.transit.realtime.nyc_subway.NyctTripDescriptor = {
      var __trainId = this.trainId
      var __isAssigned = this.isAssigned
      var __direction = this.direction
      var _done__ = false
      while (!_done__) {
        val _tag__ = _input__.readTag()
        _tag__ match {
          case 0 => _done__ = true
          case 10 =>
            __trainId = Option(_input__.readString())
          case 16 =>
            __isAssigned = Option(_input__.readBool())
          case 24 =>
            __direction = Option(com.google.transit.realtime.nyc_subway.NyctTripDescriptor.Direction.fromValue(_input__.readEnum()))
          case tag => _input__.skipField(tag)
        }
      }
      com.google.transit.realtime.nyc_subway.NyctTripDescriptor(
          trainId = __trainId,
          isAssigned = __isAssigned,
          direction = __direction
      )
    }
    def getTrainId: _root_.scala.Predef.String = trainId.getOrElse("")
    def clearTrainId: NyctTripDescriptor = copy(trainId = _root_.scala.None)
    def withTrainId(__v: _root_.scala.Predef.String): NyctTripDescriptor = copy(trainId = Option(__v))
    def getIsAssigned: _root_.scala.Boolean = isAssigned.getOrElse(false)
    def clearIsAssigned: NyctTripDescriptor = copy(isAssigned = _root_.scala.None)
    def withIsAssigned(__v: _root_.scala.Boolean): NyctTripDescriptor = copy(isAssigned = Option(__v))
    def getDirection: com.google.transit.realtime.nyc_subway.NyctTripDescriptor.Direction = direction.getOrElse(com.google.transit.realtime.nyc_subway.NyctTripDescriptor.Direction.NORTH)
    def clearDirection: NyctTripDescriptor = copy(direction = _root_.scala.None)
    def withDirection(__v: com.google.transit.realtime.nyc_subway.NyctTripDescriptor.Direction): NyctTripDescriptor = copy(direction = Option(__v))
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => trainId.orNull
        case 2 => isAssigned.orNull
        case 3 => direction.map(_.javaValueDescriptor).orNull
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => trainId.map(_root_.scalapb.descriptors.PString).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 2 => isAssigned.map(_root_.scalapb.descriptors.PBoolean).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 3 => direction.map(__e => _root_.scalapb.descriptors.PEnum(__e.scalaValueDescriptor)).getOrElse(_root_.scalapb.descriptors.PEmpty)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion = com.google.transit.realtime.nyc_subway.NyctTripDescriptor
}

object NyctTripDescriptor extends scalapb.GeneratedMessageCompanion[com.google.transit.realtime.nyc_subway.NyctTripDescriptor] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[com.google.transit.realtime.nyc_subway.NyctTripDescriptor] = this
  def fromFieldsMap(__fieldsMap: scala.collection.immutable.Map[_root_.com.google.protobuf.Descriptors.FieldDescriptor, _root_.scala.Any]): com.google.transit.realtime.nyc_subway.NyctTripDescriptor = {
    _root_.scala.Predef.require(__fieldsMap.keys.forall(_.getContainingType() == javaDescriptor), "FieldDescriptor does not match message type.")
    val __fields = javaDescriptor.getFields
    com.google.transit.realtime.nyc_subway.NyctTripDescriptor(
      __fieldsMap.get(__fields.get(0)).asInstanceOf[_root_.scala.Option[_root_.scala.Predef.String]],
      __fieldsMap.get(__fields.get(1)).asInstanceOf[_root_.scala.Option[_root_.scala.Boolean]],
      __fieldsMap.get(__fields.get(2)).asInstanceOf[_root_.scala.Option[_root_.com.google.protobuf.Descriptors.EnumValueDescriptor]].map(__e => com.google.transit.realtime.nyc_subway.NyctTripDescriptor.Direction.fromValue(__e.getNumber))
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[com.google.transit.realtime.nyc_subway.NyctTripDescriptor] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage == scalaDescriptor), "FieldDescriptor does not match message type.")
      com.google.transit.realtime.nyc_subway.NyctTripDescriptor(
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).flatMap(_.as[_root_.scala.Option[_root_.scala.Predef.String]]),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).flatMap(_.as[_root_.scala.Option[_root_.scala.Boolean]]),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(3).get).flatMap(_.as[_root_.scala.Option[_root_.scalapb.descriptors.EnumValueDescriptor]]).map(__e => com.google.transit.realtime.nyc_subway.NyctTripDescriptor.Direction.fromValue(__e.number))
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = NycSubwayProto.javaDescriptor.getMessageTypes.get(2)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = NycSubwayProto.scalaDescriptor.messages(2)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = throw new MatchError(__number)
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = {
    (__fieldNumber: @_root_.scala.unchecked) match {
      case 3 => com.google.transit.realtime.nyc_subway.NyctTripDescriptor.Direction
    }
  }
  lazy val defaultInstance = com.google.transit.realtime.nyc_subway.NyctTripDescriptor(
  )
  /** The direction the train is moving. 
    */
  sealed trait Direction extends _root_.scalapb.GeneratedEnum {
    type EnumType = Direction
    def isNorth: _root_.scala.Boolean = false
    def isEast: _root_.scala.Boolean = false
    def isSouth: _root_.scala.Boolean = false
    def isWest: _root_.scala.Boolean = false
    def companion: _root_.scalapb.GeneratedEnumCompanion[Direction] = com.google.transit.realtime.nyc_subway.NyctTripDescriptor.Direction
  }
  
  object Direction extends _root_.scalapb.GeneratedEnumCompanion[Direction] {
    implicit def enumCompanion: _root_.scalapb.GeneratedEnumCompanion[Direction] = this
    @SerialVersionUID(0L)
    case object NORTH extends Direction {
      val value = 1
      val index = 0
      val name = "NORTH"
      override def isNorth: _root_.scala.Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object EAST extends Direction {
      val value = 2
      val index = 1
      val name = "EAST"
      override def isEast: _root_.scala.Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object SOUTH extends Direction {
      val value = 3
      val index = 2
      val name = "SOUTH"
      override def isSouth: _root_.scala.Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object WEST extends Direction {
      val value = 4
      val index = 3
      val name = "WEST"
      override def isWest: _root_.scala.Boolean = true
    }
    
    @SerialVersionUID(0L)
    final case class Unrecognized(value: _root_.scala.Int) extends Direction with _root_.scalapb.UnrecognizedEnum
    
    lazy val values = scala.collection.immutable.Seq(NORTH, EAST, SOUTH, WEST)
    def fromValue(value: _root_.scala.Int): Direction = value match {
      case 1 => NORTH
      case 2 => EAST
      case 3 => SOUTH
      case 4 => WEST
      case __other => Unrecognized(__other)
    }
    def javaDescriptor: _root_.com.google.protobuf.Descriptors.EnumDescriptor = com.google.transit.realtime.nyc_subway.NyctTripDescriptor.javaDescriptor.getEnumTypes.get(0)
    def scalaDescriptor: _root_.scalapb.descriptors.EnumDescriptor = com.google.transit.realtime.nyc_subway.NyctTripDescriptor.scalaDescriptor.enums(0)
  }
  implicit class NyctTripDescriptorLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, com.google.transit.realtime.nyc_subway.NyctTripDescriptor]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, com.google.transit.realtime.nyc_subway.NyctTripDescriptor](_l) {
    def trainId: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.getTrainId)((c_, f_) => c_.copy(trainId = Option(f_)))
    def optionalTrainId: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[_root_.scala.Predef.String]] = field(_.trainId)((c_, f_) => c_.copy(trainId = f_))
    def isAssigned: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Boolean] = field(_.getIsAssigned)((c_, f_) => c_.copy(isAssigned = Option(f_)))
    def optionalIsAssigned: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[_root_.scala.Boolean]] = field(_.isAssigned)((c_, f_) => c_.copy(isAssigned = f_))
    def direction: _root_.scalapb.lenses.Lens[UpperPB, com.google.transit.realtime.nyc_subway.NyctTripDescriptor.Direction] = field(_.getDirection)((c_, f_) => c_.copy(direction = Option(f_)))
    def optionalDirection: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[com.google.transit.realtime.nyc_subway.NyctTripDescriptor.Direction]] = field(_.direction)((c_, f_) => c_.copy(direction = f_))
  }
  final val TRAIN_ID_FIELD_NUMBER = 1
  final val IS_ASSIGNED_FIELD_NUMBER = 2
  final val DIRECTION_FIELD_NUMBER = 3
  def of(
    trainId: _root_.scala.Option[_root_.scala.Predef.String],
    isAssigned: _root_.scala.Option[_root_.scala.Boolean],
    direction: _root_.scala.Option[com.google.transit.realtime.nyc_subway.NyctTripDescriptor.Direction]
  ): _root_.com.google.transit.realtime.nyc_subway.NyctTripDescriptor = _root_.com.google.transit.realtime.nyc_subway.NyctTripDescriptor(
    trainId,
    isAssigned,
    direction
  )
}
