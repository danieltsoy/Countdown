// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO2

package com.google.transit.realtime.gtfs_realtime

/** Realtime update of the progress of a vehicle along a trip.
  * Depending on the value of ScheduleRelationship, a TripUpdate can specify:
  * - A trip that proceeds along the schedule.
  * - A trip that proceeds along a route but has no fixed schedule.
  * - A trip that have been added or removed with regard to schedule.
  *
  * The updates can be for future, predicted arrival/departure events, or for
  * past events that already occurred.
  * Normally, updates should get more precise and more certain (see
  * uncertainty below) as the events gets closer to current time.
  * Even if that is not possible, the information for past events should be
  * precise and certain. In particular, if an update points to time in the past
  * but its update's uncertainty is not 0, the client should conclude that the
  * update is a (wrong) prediction and that the trip has not completed yet.
  *
  * Note that the update can describe a trip that is already completed.
  * To this end, it is enough to provide an update for the last stop of the trip.
  * If the time of that is in the past, the client will conclude from that that
  * the whole trip is in the past (it is possible, although inconsequential, to
  * also provide updates for preceding stops).
  * This option is most relevant for a trip that has completed ahead of schedule,
  * but according to the schedule, the trip is still proceeding at the current
  * time. Removing the updates for this trip could make the client assume
  * that the trip is still proceeding.
  * Note that the feed provider is allowed, but not required, to purge past
  * updates - this is one case where this would be practically useful.
  *
  * @param trip
  *   The Trip that this message applies to. There can be at most one
  *   TripUpdate entity for each actual trip instance.
  *   If there is none, that means there is no prediction information available.
  *   It does *not* mean that the trip is progressing according to schedule.
  * @param vehicle
  *   Additional information on the vehicle that is serving this trip.
  * @param stopTimeUpdate
  *   Updates to StopTimes for the trip (both future, i.e., predictions, and in
  *   some cases, past ones, i.e., those that already happened).
  *   The updates must be sorted by stop_sequence, and apply for all the
  *   following stops of the trip up to the next specified one.
  *  
  *   Example 1:
  *   For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
  *   delay of 0 for stop_sequence of the current stop means that the trip is
  *   exactly on time.
  *  
  *   Example 2:
  *   For the same trip instance, 3 StopTimeUpdates are provided:
  *   - delay of 5 min for stop_sequence 3
  *   - delay of 1 min for stop_sequence 8
  *   - delay of unspecified duration for stop_sequence 10
  *   This will be interpreted as:
  *   - stop_sequences 3,4,5,6,7 have delay of 5 min.
  *   - stop_sequences 8,9 have delay of 1 min.
  *   - stop_sequences 10,... have unknown delay.
  * @param timestamp
  *   Moment at which the vehicle's real-time progress was measured. In POSIX
  *   time (i.e., the number of seconds since January 1st 1970 00:00:00 UTC).
  * @param delay
  *   The current schedule deviation for the trip.  Delay should only be
  *   specified when the prediction is given relative to some existing schedule
  *   in GTFS.
  *  
  *   Delay (in seconds) can be positive (meaning that the vehicle is late) or
  *   negative (meaning that the vehicle is ahead of schedule). Delay of 0
  *   means that the vehicle is exactly on time.
  *  
  *   Delay information in StopTimeUpdates take precedent of trip-level delay
  *   information, such that trip-level delay is only propagated until the next
  *   stop along the trip with a StopTimeUpdate delay value specified.
  *  
  *   Feed providers are strongly encouraged to provide a TripUpdate.timestamp
  *   value indicating when the delay value was last updated, in order to
  *   evaluate the freshness of the data.
  *  
  *   NOTE: This field is still experimental, and subject to change. It may be
  *   formally adopted in the future.
  */
@SerialVersionUID(0L)
final case class TripUpdate(
    trip: com.google.transit.realtime.gtfs_realtime.TripDescriptor,
    vehicle: _root_.scala.Option[com.google.transit.realtime.gtfs_realtime.VehicleDescriptor] = _root_.scala.None,
    stopTimeUpdate: _root_.scala.Seq[com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeUpdate] = _root_.scala.Seq.empty,
    timestamp: _root_.scala.Option[_root_.scala.Long] = _root_.scala.None,
    delay: _root_.scala.Option[_root_.scala.Int] = _root_.scala.None,
    unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet()
    ) extends scalapb.GeneratedMessage with scalapb.Message[TripUpdate] with scalapb.lenses.Updatable[TripUpdate] with _root_.scalapb.ExtendableMessage[TripUpdate] {
    @transient
    private[this] var __serializedSizeCachedValue: _root_.scala.Int = 0
    private[this] def __computeSerializedValue(): _root_.scala.Int = {
      var __size = 0
      
      {
        val __value = trip
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      if (vehicle.isDefined) {
        val __value = vehicle.get
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      };
      stopTimeUpdate.foreach { __item =>
        val __value = __item
        __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
      }
      if (timestamp.isDefined) {
        val __value = timestamp.get
        __size += _root_.com.google.protobuf.CodedOutputStream.computeUInt64Size(4, __value)
      };
      if (delay.isDefined) {
        val __value = delay.get
        __size += _root_.com.google.protobuf.CodedOutputStream.computeInt32Size(5, __value)
      };
      __size += unknownFields.serializedSize
      __size
    }
    final override def serializedSize: _root_.scala.Int = {
      var read = __serializedSizeCachedValue
      if (read == 0) {
        read = __computeSerializedValue()
        __serializedSizeCachedValue = read
      }
      read
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      
      {
        val __v = trip
        _output__.writeTag(1, 2)
        _output__.writeUInt32NoTag(__v.serializedSize)
        __v.writeTo(_output__)
      };
      stopTimeUpdate.foreach { __v =>
        val __m = __v
        _output__.writeTag(2, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      vehicle.foreach { __v =>
        val __m = __v
        _output__.writeTag(3, 2)
        _output__.writeUInt32NoTag(__m.serializedSize)
        __m.writeTo(_output__)
      };
      timestamp.foreach { __v =>
        val __m = __v
        _output__.writeUInt64(4, __m)
      };
      delay.foreach { __v =>
        val __m = __v
        _output__.writeInt32(5, __m)
      };
      unknownFields.writeTo(_output__)
    }
    def mergeFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): com.google.transit.realtime.gtfs_realtime.TripUpdate = {
      var __trip = this.trip
      var __vehicle = this.vehicle
      val __stopTimeUpdate = (_root_.scala.collection.immutable.Vector.newBuilder[com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeUpdate] ++= this.stopTimeUpdate)
      var __timestamp = this.timestamp
      var __delay = this.delay
      val _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder(this.unknownFields)
      var __requiredFields0: _root_.scala.Long = 0x1L
      var _done__ = false
      while (!_done__) {
        val _tag__ = _input__.readTag()
        _tag__ match {
          case 0 => _done__ = true
          case 10 =>
            __trip = _root_.scalapb.LiteParser.readMessage(_input__, __trip)
            __requiredFields0 &= 0xfffffffffffffffeL
          case 26 =>
            __vehicle = Option(_root_.scalapb.LiteParser.readMessage(_input__, __vehicle.getOrElse(com.google.transit.realtime.gtfs_realtime.VehicleDescriptor.defaultInstance)))
          case 18 =>
            __stopTimeUpdate += _root_.scalapb.LiteParser.readMessage(_input__, com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeUpdate.defaultInstance)
          case 32 =>
            __timestamp = Option(_input__.readUInt64())
          case 40 =>
            __delay = Option(_input__.readInt32())
          case tag => _unknownFields__.parseField(tag, _input__)
        }
      }
      if (__requiredFields0 != 0L) { throw new _root_.com.google.protobuf.InvalidProtocolBufferException("Message missing required fields.") } 
      com.google.transit.realtime.gtfs_realtime.TripUpdate(
          trip = __trip,
          vehicle = __vehicle,
          stopTimeUpdate = __stopTimeUpdate.result(),
          timestamp = __timestamp,
          delay = __delay,
          unknownFields = _unknownFields__.result()
      )
    }
    def withTrip(__v: com.google.transit.realtime.gtfs_realtime.TripDescriptor): TripUpdate = copy(trip = __v)
    def getVehicle: com.google.transit.realtime.gtfs_realtime.VehicleDescriptor = vehicle.getOrElse(com.google.transit.realtime.gtfs_realtime.VehicleDescriptor.defaultInstance)
    def clearVehicle: TripUpdate = copy(vehicle = _root_.scala.None)
    def withVehicle(__v: com.google.transit.realtime.gtfs_realtime.VehicleDescriptor): TripUpdate = copy(vehicle = Option(__v))
    def clearStopTimeUpdate = copy(stopTimeUpdate = _root_.scala.Seq.empty)
    def addStopTimeUpdate(__vs: com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeUpdate*): TripUpdate = addAllStopTimeUpdate(__vs)
    def addAllStopTimeUpdate(__vs: Iterable[com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeUpdate]): TripUpdate = copy(stopTimeUpdate = stopTimeUpdate ++ __vs)
    def withStopTimeUpdate(__v: _root_.scala.Seq[com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeUpdate]): TripUpdate = copy(stopTimeUpdate = __v)
    def getTimestamp: _root_.scala.Long = timestamp.getOrElse(0L)
    def clearTimestamp: TripUpdate = copy(timestamp = _root_.scala.None)
    def withTimestamp(__v: _root_.scala.Long): TripUpdate = copy(timestamp = Option(__v))
    def getDelay: _root_.scala.Int = delay.getOrElse(0)
    def clearDelay: TripUpdate = copy(delay = _root_.scala.None)
    def withDelay(__v: _root_.scala.Int): TripUpdate = copy(delay = Option(__v))
    def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
    def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 1 => trip
        case 3 => vehicle.orNull
        case 2 => stopTimeUpdate
        case 4 => timestamp.orNull
        case 5 => delay.orNull
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 1 => trip.toPMessage
        case 3 => vehicle.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 2 => _root_.scalapb.descriptors.PRepeated(stopTimeUpdate.iterator.map(_.toPMessage).toVector)
        case 4 => timestamp.map(_root_.scalapb.descriptors.PLong).getOrElse(_root_.scalapb.descriptors.PEmpty)
        case 5 => delay.map(_root_.scalapb.descriptors.PInt).getOrElse(_root_.scalapb.descriptors.PEmpty)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion = com.google.transit.realtime.gtfs_realtime.TripUpdate
}

object TripUpdate extends scalapb.GeneratedMessageCompanion[com.google.transit.realtime.gtfs_realtime.TripUpdate] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[com.google.transit.realtime.gtfs_realtime.TripUpdate] = this
  def fromFieldsMap(__fieldsMap: scala.collection.immutable.Map[_root_.com.google.protobuf.Descriptors.FieldDescriptor, _root_.scala.Any]): com.google.transit.realtime.gtfs_realtime.TripUpdate = {
    _root_.scala.Predef.require(__fieldsMap.keys.forall(_.getContainingType() == javaDescriptor), "FieldDescriptor does not match message type.")
    val __fields = javaDescriptor.getFields
    com.google.transit.realtime.gtfs_realtime.TripUpdate(
      __fieldsMap(__fields.get(0)).asInstanceOf[com.google.transit.realtime.gtfs_realtime.TripDescriptor],
      __fieldsMap.get(__fields.get(1)).asInstanceOf[_root_.scala.Option[com.google.transit.realtime.gtfs_realtime.VehicleDescriptor]],
      __fieldsMap.getOrElse(__fields.get(2), Nil).asInstanceOf[_root_.scala.Seq[com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeUpdate]],
      __fieldsMap.get(__fields.get(3)).asInstanceOf[_root_.scala.Option[_root_.scala.Long]],
      __fieldsMap.get(__fields.get(4)).asInstanceOf[_root_.scala.Option[_root_.scala.Int]]
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[com.google.transit.realtime.gtfs_realtime.TripUpdate] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage == scalaDescriptor), "FieldDescriptor does not match message type.")
      com.google.transit.realtime.gtfs_realtime.TripUpdate(
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).get.as[com.google.transit.realtime.gtfs_realtime.TripDescriptor],
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(3).get).flatMap(_.as[_root_.scala.Option[com.google.transit.realtime.gtfs_realtime.VehicleDescriptor]]),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).map(_.as[_root_.scala.Seq[com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeUpdate]]).getOrElse(_root_.scala.Seq.empty),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(4).get).flatMap(_.as[_root_.scala.Option[_root_.scala.Long]]),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(5).get).flatMap(_.as[_root_.scala.Option[_root_.scala.Int]])
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = GtfsRealtimeProto.javaDescriptor.getMessageTypes.get(3)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = GtfsRealtimeProto.scalaDescriptor.messages(3)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = {
    var __out: _root_.scalapb.GeneratedMessageCompanion[_] = null
    (__number: @_root_.scala.unchecked) match {
      case 1 => __out = com.google.transit.realtime.gtfs_realtime.TripDescriptor
      case 3 => __out = com.google.transit.realtime.gtfs_realtime.VehicleDescriptor
      case 2 => __out = com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeUpdate
    }
    __out
  }
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] =
    Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]](
      _root_.com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeEvent,
      _root_.com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeUpdate
    )
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
  lazy val defaultInstance = com.google.transit.realtime.gtfs_realtime.TripUpdate(
    trip = com.google.transit.realtime.gtfs_realtime.TripDescriptor.defaultInstance
  )
  /** Timing information for a single predicted event (either arrival or
    * departure).
    * Timing consists of delay and/or estimated time, and uncertainty.
    * - delay should be used when the prediction is given relative to some
    *   existing schedule in GTFS.
    * - time should be given whether there is a predicted schedule or not. If
    *   both time and delay are specified, time will take precedence
    *   (although normally, time, if given for a scheduled trip, should be
    *   equal to scheduled time in GTFS + delay).
    *
    * Uncertainty applies equally to both time and delay.
    * The uncertainty roughly specifies the expected error in true delay (but
    * note, we don't yet define its precise statistical meaning). It's possible
    * for the uncertainty to be 0, for example for trains that are driven under
    * computer timing control.
    *
    * @param delay
    *   Delay (in seconds) can be positive (meaning that the vehicle is late) or
    *   negative (meaning that the vehicle is ahead of schedule). Delay of 0
    *   means that the vehicle is exactly on time.
    * @param time
    *   Event as absolute time.
    *   In Unix time (i.e., number of seconds since January 1st 1970 00:00:00
    *   UTC).
    * @param uncertainty
    *   If uncertainty is omitted, it is interpreted as unknown.
    *   If the prediction is unknown or too uncertain, the delay (or time) field
    *   should be empty. In such case, the uncertainty field is ignored.
    *   To specify a completely certain prediction, set its uncertainty to 0.
    */
  @SerialVersionUID(0L)
  final case class StopTimeEvent(
      delay: _root_.scala.Option[_root_.scala.Int] = _root_.scala.None,
      time: _root_.scala.Option[_root_.scala.Long] = _root_.scala.None,
      uncertainty: _root_.scala.Option[_root_.scala.Int] = _root_.scala.None,
      unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet()
      ) extends scalapb.GeneratedMessage with scalapb.Message[StopTimeEvent] with scalapb.lenses.Updatable[StopTimeEvent] with _root_.scalapb.ExtendableMessage[StopTimeEvent] {
      @transient
      private[this] var __serializedSizeCachedValue: _root_.scala.Int = 0
      private[this] def __computeSerializedValue(): _root_.scala.Int = {
        var __size = 0
        if (delay.isDefined) {
          val __value = delay.get
          __size += _root_.com.google.protobuf.CodedOutputStream.computeInt32Size(1, __value)
        };
        if (time.isDefined) {
          val __value = time.get
          __size += _root_.com.google.protobuf.CodedOutputStream.computeInt64Size(2, __value)
        };
        if (uncertainty.isDefined) {
          val __value = uncertainty.get
          __size += _root_.com.google.protobuf.CodedOutputStream.computeInt32Size(3, __value)
        };
        __size += unknownFields.serializedSize
        __size
      }
      final override def serializedSize: _root_.scala.Int = {
        var read = __serializedSizeCachedValue
        if (read == 0) {
          read = __computeSerializedValue()
          __serializedSizeCachedValue = read
        }
        read
      }
      def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
        delay.foreach { __v =>
          val __m = __v
          _output__.writeInt32(1, __m)
        };
        time.foreach { __v =>
          val __m = __v
          _output__.writeInt64(2, __m)
        };
        uncertainty.foreach { __v =>
          val __m = __v
          _output__.writeInt32(3, __m)
        };
        unknownFields.writeTo(_output__)
      }
      def mergeFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeEvent = {
        var __delay = this.delay
        var __time = this.time
        var __uncertainty = this.uncertainty
        val _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder(this.unknownFields)
        var _done__ = false
        while (!_done__) {
          val _tag__ = _input__.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 8 =>
              __delay = Option(_input__.readInt32())
            case 16 =>
              __time = Option(_input__.readInt64())
            case 24 =>
              __uncertainty = Option(_input__.readInt32())
            case tag => _unknownFields__.parseField(tag, _input__)
          }
        }
        com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeEvent(
            delay = __delay,
            time = __time,
            uncertainty = __uncertainty,
            unknownFields = _unknownFields__.result()
        )
      }
      def getDelay: _root_.scala.Int = delay.getOrElse(0)
      def clearDelay: StopTimeEvent = copy(delay = _root_.scala.None)
      def withDelay(__v: _root_.scala.Int): StopTimeEvent = copy(delay = Option(__v))
      def getTime: _root_.scala.Long = time.getOrElse(0L)
      def clearTime: StopTimeEvent = copy(time = _root_.scala.None)
      def withTime(__v: _root_.scala.Long): StopTimeEvent = copy(time = Option(__v))
      def getUncertainty: _root_.scala.Int = uncertainty.getOrElse(0)
      def clearUncertainty: StopTimeEvent = copy(uncertainty = _root_.scala.None)
      def withUncertainty(__v: _root_.scala.Int): StopTimeEvent = copy(uncertainty = Option(__v))
      def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
      def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
      def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
        (__fieldNumber: @_root_.scala.unchecked) match {
          case 1 => delay.orNull
          case 2 => time.orNull
          case 3 => uncertainty.orNull
        }
      }
      def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
        _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
        (__field.number: @_root_.scala.unchecked) match {
          case 1 => delay.map(_root_.scalapb.descriptors.PInt).getOrElse(_root_.scalapb.descriptors.PEmpty)
          case 2 => time.map(_root_.scalapb.descriptors.PLong).getOrElse(_root_.scalapb.descriptors.PEmpty)
          case 3 => uncertainty.map(_root_.scalapb.descriptors.PInt).getOrElse(_root_.scalapb.descriptors.PEmpty)
        }
      }
      def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
      def companion = com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeEvent
  }
  
  object StopTimeEvent extends scalapb.GeneratedMessageCompanion[com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeEvent] {
    implicit def messageCompanion: scalapb.GeneratedMessageCompanion[com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeEvent] = this
    def fromFieldsMap(__fieldsMap: scala.collection.immutable.Map[_root_.com.google.protobuf.Descriptors.FieldDescriptor, _root_.scala.Any]): com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeEvent = {
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.getContainingType() == javaDescriptor), "FieldDescriptor does not match message type.")
      val __fields = javaDescriptor.getFields
      com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeEvent(
        __fieldsMap.get(__fields.get(0)).asInstanceOf[_root_.scala.Option[_root_.scala.Int]],
        __fieldsMap.get(__fields.get(1)).asInstanceOf[_root_.scala.Option[_root_.scala.Long]],
        __fieldsMap.get(__fields.get(2)).asInstanceOf[_root_.scala.Option[_root_.scala.Int]]
      )
    }
    implicit def messageReads: _root_.scalapb.descriptors.Reads[com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeEvent] = _root_.scalapb.descriptors.Reads{
      case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
        _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage == scalaDescriptor), "FieldDescriptor does not match message type.")
        com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeEvent(
          __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).flatMap(_.as[_root_.scala.Option[_root_.scala.Int]]),
          __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).flatMap(_.as[_root_.scala.Option[_root_.scala.Long]]),
          __fieldsMap.get(scalaDescriptor.findFieldByNumber(3).get).flatMap(_.as[_root_.scala.Option[_root_.scala.Int]])
        )
      case _ => throw new RuntimeException("Expected PMessage")
    }
    def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = com.google.transit.realtime.gtfs_realtime.TripUpdate.javaDescriptor.getNestedTypes.get(0)
    def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = com.google.transit.realtime.gtfs_realtime.TripUpdate.scalaDescriptor.nestedMessages(0)
    def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = throw new MatchError(__number)
    lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
    def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
    lazy val defaultInstance = com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeEvent(
    )
    implicit class StopTimeEventLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeEvent]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeEvent](_l) {
      def delay: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Int] = field(_.getDelay)((c_, f_) => c_.copy(delay = Option(f_)))
      def optionalDelay: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[_root_.scala.Int]] = field(_.delay)((c_, f_) => c_.copy(delay = f_))
      def time: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Long] = field(_.getTime)((c_, f_) => c_.copy(time = Option(f_)))
      def optionalTime: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[_root_.scala.Long]] = field(_.time)((c_, f_) => c_.copy(time = f_))
      def uncertainty: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Int] = field(_.getUncertainty)((c_, f_) => c_.copy(uncertainty = Option(f_)))
      def optionalUncertainty: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[_root_.scala.Int]] = field(_.uncertainty)((c_, f_) => c_.copy(uncertainty = f_))
    }
    final val DELAY_FIELD_NUMBER = 1
    final val TIME_FIELD_NUMBER = 2
    final val UNCERTAINTY_FIELD_NUMBER = 3
    def of(
      delay: _root_.scala.Option[_root_.scala.Int],
      time: _root_.scala.Option[_root_.scala.Long],
      uncertainty: _root_.scala.Option[_root_.scala.Int],
      unknownFields: _root_.scalapb.UnknownFieldSet
    ): _root_.com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeEvent = _root_.com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeEvent(
      delay,
      time,
      uncertainty,
      unknownFields
    )
  }
  
  /** Realtime update for arrival and/or departure events for a given stop on a
    * trip. Updates can be supplied for both past and future events.
    * The producer is allowed, although not required, to drop past events.
    * The update is linked to a specific stop either through stop_sequence or
    * stop_id, so one of the fields below must necessarily be set.
    * See the documentation in TripDescriptor for more information.
    *
    * @param stopSequence
    *   Must be the same as in stop_times.txt in the corresponding GTFS feed.
    * @param stopId
    *   Must be the same as in stops.txt in the corresponding GTFS feed.
    */
  @SerialVersionUID(0L)
  final case class StopTimeUpdate(
      stopSequence: _root_.scala.Option[_root_.scala.Int] = _root_.scala.None,
      stopId: _root_.scala.Option[_root_.scala.Predef.String] = _root_.scala.None,
      arrival: _root_.scala.Option[com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeEvent] = _root_.scala.None,
      departure: _root_.scala.Option[com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeEvent] = _root_.scala.None,
      scheduleRelationship: _root_.scala.Option[com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship] = _root_.scala.None,
      unknownFields: _root_.scalapb.UnknownFieldSet = _root_.scalapb.UnknownFieldSet()
      ) extends scalapb.GeneratedMessage with scalapb.Message[StopTimeUpdate] with scalapb.lenses.Updatable[StopTimeUpdate] with _root_.scalapb.ExtendableMessage[StopTimeUpdate] {
      @transient
      private[this] var __serializedSizeCachedValue: _root_.scala.Int = 0
      private[this] def __computeSerializedValue(): _root_.scala.Int = {
        var __size = 0
        if (stopSequence.isDefined) {
          val __value = stopSequence.get
          __size += _root_.com.google.protobuf.CodedOutputStream.computeUInt32Size(1, __value)
        };
        if (stopId.isDefined) {
          val __value = stopId.get
          __size += _root_.com.google.protobuf.CodedOutputStream.computeStringSize(4, __value)
        };
        if (arrival.isDefined) {
          val __value = arrival.get
          __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
        };
        if (departure.isDefined) {
          val __value = departure.get
          __size += 1 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(__value.serializedSize) + __value.serializedSize
        };
        if (scheduleRelationship.isDefined) {
          val __value = scheduleRelationship.get
          __size += _root_.com.google.protobuf.CodedOutputStream.computeEnumSize(5, __value.value)
        };
        __size += unknownFields.serializedSize
        __size
      }
      final override def serializedSize: _root_.scala.Int = {
        var read = __serializedSizeCachedValue
        if (read == 0) {
          read = __computeSerializedValue()
          __serializedSizeCachedValue = read
        }
        read
      }
      def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
        stopSequence.foreach { __v =>
          val __m = __v
          _output__.writeUInt32(1, __m)
        };
        arrival.foreach { __v =>
          val __m = __v
          _output__.writeTag(2, 2)
          _output__.writeUInt32NoTag(__m.serializedSize)
          __m.writeTo(_output__)
        };
        departure.foreach { __v =>
          val __m = __v
          _output__.writeTag(3, 2)
          _output__.writeUInt32NoTag(__m.serializedSize)
          __m.writeTo(_output__)
        };
        stopId.foreach { __v =>
          val __m = __v
          _output__.writeString(4, __m)
        };
        scheduleRelationship.foreach { __v =>
          val __m = __v
          _output__.writeEnum(5, __m.value)
        };
        unknownFields.writeTo(_output__)
      }
      def mergeFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeUpdate = {
        var __stopSequence = this.stopSequence
        var __stopId = this.stopId
        var __arrival = this.arrival
        var __departure = this.departure
        var __scheduleRelationship = this.scheduleRelationship
        val _unknownFields__ = new _root_.scalapb.UnknownFieldSet.Builder(this.unknownFields)
        var _done__ = false
        while (!_done__) {
          val _tag__ = _input__.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 8 =>
              __stopSequence = Option(_input__.readUInt32())
            case 34 =>
              __stopId = Option(_input__.readString())
            case 18 =>
              __arrival = Option(_root_.scalapb.LiteParser.readMessage(_input__, __arrival.getOrElse(com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeEvent.defaultInstance)))
            case 26 =>
              __departure = Option(_root_.scalapb.LiteParser.readMessage(_input__, __departure.getOrElse(com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeEvent.defaultInstance)))
            case 40 =>
              __scheduleRelationship = Option(com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship.fromValue(_input__.readEnum()))
            case tag => _unknownFields__.parseField(tag, _input__)
          }
        }
        com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeUpdate(
            stopSequence = __stopSequence,
            stopId = __stopId,
            arrival = __arrival,
            departure = __departure,
            scheduleRelationship = __scheduleRelationship,
            unknownFields = _unknownFields__.result()
        )
      }
      def getStopSequence: _root_.scala.Int = stopSequence.getOrElse(0)
      def clearStopSequence: StopTimeUpdate = copy(stopSequence = _root_.scala.None)
      def withStopSequence(__v: _root_.scala.Int): StopTimeUpdate = copy(stopSequence = Option(__v))
      def getStopId: _root_.scala.Predef.String = stopId.getOrElse("")
      def clearStopId: StopTimeUpdate = copy(stopId = _root_.scala.None)
      def withStopId(__v: _root_.scala.Predef.String): StopTimeUpdate = copy(stopId = Option(__v))
      def getArrival: com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeEvent = arrival.getOrElse(com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeEvent.defaultInstance)
      def clearArrival: StopTimeUpdate = copy(arrival = _root_.scala.None)
      def withArrival(__v: com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeEvent): StopTimeUpdate = copy(arrival = Option(__v))
      def getDeparture: com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeEvent = departure.getOrElse(com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeEvent.defaultInstance)
      def clearDeparture: StopTimeUpdate = copy(departure = _root_.scala.None)
      def withDeparture(__v: com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeEvent): StopTimeUpdate = copy(departure = Option(__v))
      def getScheduleRelationship: com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship = scheduleRelationship.getOrElse(com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship.SCHEDULED)
      def clearScheduleRelationship: StopTimeUpdate = copy(scheduleRelationship = _root_.scala.None)
      def withScheduleRelationship(__v: com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship): StopTimeUpdate = copy(scheduleRelationship = Option(__v))
      def withUnknownFields(__v: _root_.scalapb.UnknownFieldSet) = copy(unknownFields = __v)
      def discardUnknownFields = copy(unknownFields = _root_.scalapb.UnknownFieldSet.empty)
      def getFieldByNumber(__fieldNumber: _root_.scala.Int): _root_.scala.Any = {
        (__fieldNumber: @_root_.scala.unchecked) match {
          case 1 => stopSequence.orNull
          case 4 => stopId.orNull
          case 2 => arrival.orNull
          case 3 => departure.orNull
          case 5 => scheduleRelationship.map(_.javaValueDescriptor).orNull
        }
      }
      def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
        _root_.scala.Predef.require(__field.containingMessage eq companion.scalaDescriptor)
        (__field.number: @_root_.scala.unchecked) match {
          case 1 => stopSequence.map(_root_.scalapb.descriptors.PInt).getOrElse(_root_.scalapb.descriptors.PEmpty)
          case 4 => stopId.map(_root_.scalapb.descriptors.PString).getOrElse(_root_.scalapb.descriptors.PEmpty)
          case 2 => arrival.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
          case 3 => departure.map(_.toPMessage).getOrElse(_root_.scalapb.descriptors.PEmpty)
          case 5 => scheduleRelationship.map(__e => _root_.scalapb.descriptors.PEnum(__e.scalaValueDescriptor)).getOrElse(_root_.scalapb.descriptors.PEmpty)
        }
      }
      def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
      def companion = com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeUpdate
  }
  
  object StopTimeUpdate extends scalapb.GeneratedMessageCompanion[com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeUpdate] {
    implicit def messageCompanion: scalapb.GeneratedMessageCompanion[com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeUpdate] = this
    def fromFieldsMap(__fieldsMap: scala.collection.immutable.Map[_root_.com.google.protobuf.Descriptors.FieldDescriptor, _root_.scala.Any]): com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeUpdate = {
      _root_.scala.Predef.require(__fieldsMap.keys.forall(_.getContainingType() == javaDescriptor), "FieldDescriptor does not match message type.")
      val __fields = javaDescriptor.getFields
      com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeUpdate(
        __fieldsMap.get(__fields.get(0)).asInstanceOf[_root_.scala.Option[_root_.scala.Int]],
        __fieldsMap.get(__fields.get(1)).asInstanceOf[_root_.scala.Option[_root_.scala.Predef.String]],
        __fieldsMap.get(__fields.get(2)).asInstanceOf[_root_.scala.Option[com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeEvent]],
        __fieldsMap.get(__fields.get(3)).asInstanceOf[_root_.scala.Option[com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeEvent]],
        __fieldsMap.get(__fields.get(4)).asInstanceOf[_root_.scala.Option[_root_.com.google.protobuf.Descriptors.EnumValueDescriptor]].map(__e => com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship.fromValue(__e.getNumber))
      )
    }
    implicit def messageReads: _root_.scalapb.descriptors.Reads[com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeUpdate] = _root_.scalapb.descriptors.Reads{
      case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
        _root_.scala.Predef.require(__fieldsMap.keys.forall(_.containingMessage == scalaDescriptor), "FieldDescriptor does not match message type.")
        com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeUpdate(
          __fieldsMap.get(scalaDescriptor.findFieldByNumber(1).get).flatMap(_.as[_root_.scala.Option[_root_.scala.Int]]),
          __fieldsMap.get(scalaDescriptor.findFieldByNumber(4).get).flatMap(_.as[_root_.scala.Option[_root_.scala.Predef.String]]),
          __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).flatMap(_.as[_root_.scala.Option[com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeEvent]]),
          __fieldsMap.get(scalaDescriptor.findFieldByNumber(3).get).flatMap(_.as[_root_.scala.Option[com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeEvent]]),
          __fieldsMap.get(scalaDescriptor.findFieldByNumber(5).get).flatMap(_.as[_root_.scala.Option[_root_.scalapb.descriptors.EnumValueDescriptor]]).map(__e => com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship.fromValue(__e.number))
        )
      case _ => throw new RuntimeException("Expected PMessage")
    }
    def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = com.google.transit.realtime.gtfs_realtime.TripUpdate.javaDescriptor.getNestedTypes.get(1)
    def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = com.google.transit.realtime.gtfs_realtime.TripUpdate.scalaDescriptor.nestedMessages(1)
    def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = {
      var __out: _root_.scalapb.GeneratedMessageCompanion[_] = null
      (__number: @_root_.scala.unchecked) match {
        case 2 => __out = com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeEvent
        case 3 => __out = com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeEvent
      }
      __out
    }
    lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_ <: _root_.scalapb.GeneratedMessage]] = Seq.empty
    def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 5 => com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship
      }
    }
    lazy val defaultInstance = com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeUpdate(
    )
    /** The relation between this StopTime and the static schedule.
      */
    sealed trait ScheduleRelationship extends _root_.scalapb.GeneratedEnum {
      type EnumType = ScheduleRelationship
      def isScheduled: _root_.scala.Boolean = false
      def isSkipped: _root_.scala.Boolean = false
      def isNoData: _root_.scala.Boolean = false
      def companion: _root_.scalapb.GeneratedEnumCompanion[ScheduleRelationship] = com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship
    }
    
    object ScheduleRelationship extends _root_.scalapb.GeneratedEnumCompanion[ScheduleRelationship] {
      implicit def enumCompanion: _root_.scalapb.GeneratedEnumCompanion[ScheduleRelationship] = this
      /** The vehicle is proceeding in accordance with its static schedule of
        * stops, although not necessarily according to the times of the schedule.
        * At least one of arrival and departure must be provided. If the schedule
        * for this stop contains both arrival and departure times then so must
        * this update.
        */
      @SerialVersionUID(0L)
      case object SCHEDULED extends ScheduleRelationship {
        val value = 0
        val index = 0
        val name = "SCHEDULED"
        override def isScheduled: _root_.scala.Boolean = true
      }
      
      /** The stop is skipped, i.e., the vehicle will not stop at this stop.
        * Arrival and departure are optional.
        */
      @SerialVersionUID(0L)
      case object SKIPPED extends ScheduleRelationship {
        val value = 1
        val index = 1
        val name = "SKIPPED"
        override def isSkipped: _root_.scala.Boolean = true
      }
      
      /** No data is given for this stop. The main intention for this value is to
        * give the predictions only for part of a trip, i.e., if the last update
        * for a trip has a NO_DATA specifier, then StopTimes for the rest of the
        * stops in the trip are considered to be unspecified as well.
        * Neither arrival nor departure should be supplied.
        */
      @SerialVersionUID(0L)
      case object NO_DATA extends ScheduleRelationship {
        val value = 2
        val index = 2
        val name = "NO_DATA"
        override def isNoData: _root_.scala.Boolean = true
      }
      
      @SerialVersionUID(0L)
      final case class Unrecognized(value: _root_.scala.Int) extends ScheduleRelationship with _root_.scalapb.UnrecognizedEnum
      
      lazy val values = scala.collection.immutable.Seq(SCHEDULED, SKIPPED, NO_DATA)
      def fromValue(value: _root_.scala.Int): ScheduleRelationship = value match {
        case 0 => SCHEDULED
        case 1 => SKIPPED
        case 2 => NO_DATA
        case __other => Unrecognized(__other)
      }
      def javaDescriptor: _root_.com.google.protobuf.Descriptors.EnumDescriptor = com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeUpdate.javaDescriptor.getEnumTypes.get(0)
      def scalaDescriptor: _root_.scalapb.descriptors.EnumDescriptor = com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeUpdate.scalaDescriptor.enums(0)
    }
    implicit class StopTimeUpdateLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeUpdate]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeUpdate](_l) {
      def stopSequence: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Int] = field(_.getStopSequence)((c_, f_) => c_.copy(stopSequence = Option(f_)))
      def optionalStopSequence: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[_root_.scala.Int]] = field(_.stopSequence)((c_, f_) => c_.copy(stopSequence = f_))
      def stopId: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Predef.String] = field(_.getStopId)((c_, f_) => c_.copy(stopId = Option(f_)))
      def optionalStopId: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[_root_.scala.Predef.String]] = field(_.stopId)((c_, f_) => c_.copy(stopId = f_))
      def arrival: _root_.scalapb.lenses.Lens[UpperPB, com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeEvent] = field(_.getArrival)((c_, f_) => c_.copy(arrival = Option(f_)))
      def optionalArrival: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeEvent]] = field(_.arrival)((c_, f_) => c_.copy(arrival = f_))
      def departure: _root_.scalapb.lenses.Lens[UpperPB, com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeEvent] = field(_.getDeparture)((c_, f_) => c_.copy(departure = Option(f_)))
      def optionalDeparture: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeEvent]] = field(_.departure)((c_, f_) => c_.copy(departure = f_))
      def scheduleRelationship: _root_.scalapb.lenses.Lens[UpperPB, com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship] = field(_.getScheduleRelationship)((c_, f_) => c_.copy(scheduleRelationship = Option(f_)))
      def optionalScheduleRelationship: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship]] = field(_.scheduleRelationship)((c_, f_) => c_.copy(scheduleRelationship = f_))
    }
    final val STOP_SEQUENCE_FIELD_NUMBER = 1
    final val STOP_ID_FIELD_NUMBER = 4
    final val ARRIVAL_FIELD_NUMBER = 2
    final val DEPARTURE_FIELD_NUMBER = 3
    final val SCHEDULE_RELATIONSHIP_FIELD_NUMBER = 5
    def of(
      stopSequence: _root_.scala.Option[_root_.scala.Int],
      stopId: _root_.scala.Option[_root_.scala.Predef.String],
      arrival: _root_.scala.Option[com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeEvent],
      departure: _root_.scala.Option[com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeEvent],
      scheduleRelationship: _root_.scala.Option[com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship],
      unknownFields: _root_.scalapb.UnknownFieldSet
    ): _root_.com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeUpdate = _root_.com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeUpdate(
      stopSequence,
      stopId,
      arrival,
      departure,
      scheduleRelationship,
      unknownFields
    )
  }
  
  implicit class TripUpdateLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, com.google.transit.realtime.gtfs_realtime.TripUpdate]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, com.google.transit.realtime.gtfs_realtime.TripUpdate](_l) {
    def trip: _root_.scalapb.lenses.Lens[UpperPB, com.google.transit.realtime.gtfs_realtime.TripDescriptor] = field(_.trip)((c_, f_) => c_.copy(trip = f_))
    def vehicle: _root_.scalapb.lenses.Lens[UpperPB, com.google.transit.realtime.gtfs_realtime.VehicleDescriptor] = field(_.getVehicle)((c_, f_) => c_.copy(vehicle = Option(f_)))
    def optionalVehicle: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[com.google.transit.realtime.gtfs_realtime.VehicleDescriptor]] = field(_.vehicle)((c_, f_) => c_.copy(vehicle = f_))
    def stopTimeUpdate: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Seq[com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeUpdate]] = field(_.stopTimeUpdate)((c_, f_) => c_.copy(stopTimeUpdate = f_))
    def timestamp: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Long] = field(_.getTimestamp)((c_, f_) => c_.copy(timestamp = Option(f_)))
    def optionalTimestamp: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[_root_.scala.Long]] = field(_.timestamp)((c_, f_) => c_.copy(timestamp = f_))
    def delay: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Int] = field(_.getDelay)((c_, f_) => c_.copy(delay = Option(f_)))
    def optionalDelay: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Option[_root_.scala.Int]] = field(_.delay)((c_, f_) => c_.copy(delay = f_))
  }
  final val TRIP_FIELD_NUMBER = 1
  final val VEHICLE_FIELD_NUMBER = 3
  final val STOP_TIME_UPDATE_FIELD_NUMBER = 2
  final val TIMESTAMP_FIELD_NUMBER = 4
  final val DELAY_FIELD_NUMBER = 5
  def of(
    trip: com.google.transit.realtime.gtfs_realtime.TripDescriptor,
    vehicle: _root_.scala.Option[com.google.transit.realtime.gtfs_realtime.VehicleDescriptor],
    stopTimeUpdate: _root_.scala.Seq[com.google.transit.realtime.gtfs_realtime.TripUpdate.StopTimeUpdate],
    timestamp: _root_.scala.Option[_root_.scala.Long],
    delay: _root_.scala.Option[_root_.scala.Int],
    unknownFields: _root_.scalapb.UnknownFieldSet
  ): _root_.com.google.transit.realtime.gtfs_realtime.TripUpdate = _root_.com.google.transit.realtime.gtfs_realtime.TripUpdate(
    trip,
    vehicle,
    stopTimeUpdate,
    timestamp,
    delay,
    unknownFields
  )
}
